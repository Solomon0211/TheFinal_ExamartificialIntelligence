# -*- coding: utf-8 -*-
"""thi.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1snzg1Q0w0kwRLsb501EQGrc35f77_8vU

#  Support Vector Machine (SVM) 
Thuật toán SVM (Support Vector Machine) là một thuật toán học máy phân loại mạnh mẽ và được sử dụng rộng rãi trong nhiều lĩnh vực khác nhau.

Một số ưu điểm của thuật toán SVM bao gồm:

* Hiệu quả: Thuật toán SVM hiệu quả trong việc giải quyết các bài toán phân loại tuyến tính và phi tuyến tính, đặc biệt là trong những tập dữ liệu lớn.

* Độ chính xác cao: SVM cung cấp độ chính xác cao khi phân loại dữ liệu. Nó có khả năng xử lý nhiễu tốt và giảm thiểu việc overfitting.

* Có thể xử lý dữ liệu phi tuyến tính: SVM có thể xử lý dữ liệu phi tuyến tính thông qua các kernel như Gaussian, Polynomial, Sigmoid.

* Dễ dàng tùy chỉnh: SVM cung cấp cho người dùng một số lựa chọn tùy chỉnh như lựa chọn kernel, cách định nghĩa hàm mục tiêu và lựa chọn các siêu tham số.

Khi nào nên sử dụng SVM:

* Khi dữ liệu đầu vào có số chiều lớn, SVM có thể hiệu quả trong việc phân loại dữ liệu.

* Khi các lớp dữ liệu có đặc tính phi tuyến tính, SVM cung cấp giải pháp hiệu quả để phân loại dữ liệu.

* Khi độ chính xác cao và khả năng xử lý nhiễu là yêu cầu quan trọng, SVM là một lựa chọn tốt.

* Khi muốn điều chỉnh các siêu tham số để tăng độ chính xác, SVM cung cấp cho người dùng nhiều tùy chọn để điều chỉnh và cải thiện kết quả phân loại.
"""

#Đọc dữ liệu từ file csv
import pandas as pd
import numpy as np
from sklearn import preprocessing
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.svm  import SVC # suport vector classification
from sklearn.metrics import accuracy_score
data = pd.read_csv("Hotel Reservations.csv", index_col= 'Booking_ID')
data

data.info()

# Tiền xử lý dữ liệu
categorical_columns = ['type_of_meal_plan', 'room_type_reserved', 'market_segment_type']
for column in categorical_columns:
    encoder = preprocessing.LabelEncoder()
    data[column] = encoder.fit_transform(data[column])

# print(data['arrival_date'].value_counts())
# print(data['arrival_month'].value_counts())
# print(data['arrival_year'].value_counts())


# ValueError: day is out of range for month

# Lấy số ngày tối đa của mỗi tháng
max_days = pd.Series([31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31])

# Chỉnh sửa các giá trị không hợp lệ của arrival_day
data['arrival_date'] = data[['arrival_date', 'arrival_month']].apply(lambda x: min(x[0], max_days[x[1]-1]), axis=1)

date = pd.to_datetime(data['arrival_year']*10000 + data['arrival_month']*100 + data['arrival_date'], format='%Y%m%d')
data['day_of_week'] = date.dt.dayofweek
# 0 = thứ 2
# 1= thứ 3
# 2 = thứ 4
# 3 = thứ 5
# 4 = thứ 6 
# 5= thứ 7 
# 6 = chủ nhật
data['weekend'] = (data['day_of_week'] >= 5).astype(int)

date

for col in data.columns:
  missing_data = data[col].isna().sum()
  missing_pecent = (missing_data/len(col))*100
  print(f"Missing {col}: has {missing_pecent}% missing data")

# Tiền xử lý dữ liệu
# X = data.drop(['booking_status', 'day_of_week'], axis=1)

X = data.drop(['booking_status'], axis=1)
Y = data['booking_status']
X
Y

# Tiền xử lý dữ liệu
# trong dữ liệu sẽ có các dữ liệu fail nên phải thay thể các dữ liệu đó
# ở đây hàm SimpleInputer dùng để thay thế dữ liệu và mean là thay thể dữ liệu của các c ột còn lại
# ngoài ra còn có constant, median, most frequent
from sklearn.impute import SimpleImputer
imputer = SimpleImputer(missing_values = np.nan,strategy="mean")
# imputer.fit(X[: 8,])
# X.iloc[:, 8:] =imputer.fit_transform(X.iloc[:, 8:])
X =imputer.fit_transform(X)
X

# Tiền xử lý dữ liệu
# Choose feaatures to train SVM model
# Chọn các đặc trưng của data để train svm model
# features = ['lead_time', 'avg_price_per_room', 'no_of_special_requests', 'required_car_parking_space','no_of_adults','no_of_children','no_of_weekend_nights','no_of_week_nights']
# x = data.drop(['booking_status'], axis=1)
x = X
# y= data['booking_status']
y = Y

# Tiền xử lý dữ liệu
x_train,x_test,y_train,y_test= train_test_split(x,y,train_size= 0.8,test_size= 0.2, random_state=0)

# chuẩn hoá về  trung bình bằng 0 và độ lệch chuẩn là 1
# Loại bỏ ảnh hưởng của đơn vị đo
#Tăng hiệu suất của các thuật toán học máy
#Hỗ trợ trong việc khám phá dữ liệu và trực quan hóa
scaler = StandardScaler().fit(x_train)
x_train = scaler.transform(x_train)
x_test = scaler.transform(x_test)

svm_model = SVC(kernel='linear', C=1, random_state=0)
svm_model.fit(x_train, y_train)
# kernel='linear': Sử dụng kernel tuyến tính trong thuật toán SVM để phân loại dữ liệu
# Kernel là một hàm chuyển đổi dữ liệu đầu vào thành một không gian cao chiều hơn để giúp phân loại dữ liệu một cách hiệu quả hơn.

# C=1: Tham số điều chỉnh độ ràng buộc (constraint) của thuật toán SVM.
# Giá trị C càng lớn thì mô hình sẽ càng có xu hướng chấp nhận những điểm dữ liệu gần đường biên hơn, dẫn đến độ chính xác trên tập huấn luyện cao hơn,
#  tuy nhiên có thể gây ra overfitting.

# random_state=0: Tham số này được sử dụng để thiết lập một giá trị seed (nguồn mầm) cho bộ sinh số ngẫu nhiên 
#  (random number generator) được sử dụng trong quá trình huấn luyện mô hình. Việc thiết lập seed sẽ giúp mô hình đảm bảo kết quả phân loại
#   được tái tạo được nếu chúng ta chạy lại mô hình với các tham số và dữ liệu giống nhau.

# Sử dụng mô hình để dự đoán trên tập kiểm tra và tính độ chính xác
y_pred = svm_model.predict(x_test)
accuracy = accuracy_score(y_test,y_pred)

print('Độ chính xác của mô hình là: {:.2f}%'.format(accuracy * 100))

#Thêm 1 bộ test để test